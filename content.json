{"meta":{"title":"我的博客","subtitle":"","description":"","author":"yuan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"react","slug":"react","date":"2020-11-30T16:00:00.000Z","updated":"2021-08-26T09:49:58.590Z","comments":true,"path":"2020/12/01/react/","link":"","permalink":"http://yoursite.com/2020/12/01/react/","excerpt":"react 使用","text":"react 使用 1.基础 定义：用于构建用户界面的 javascript 库 全家桶：React-Router，Axios，Redux，Mobx，Hooks，Ant-Design，Typescript super 中传入 props，若不传入，在 construct 内打印 this.props 返回 undefined class 需要替换为 className，for 需要替换为 htmlFor 2. 函数的声明 函数组件默认参数：props class 组件内置属性： props，state，refs，context state 和 fn，fn2 挂载在 this 上，fn 和 fn2 作为内置方法，fn3 挂载在 this 的原型上 1234567constructor() &#123; super(); console.log(this); this.fn = () =&gt; &#123;&#125;;&#125;fn2 = () =&gt; &#123;&#125;;fn3() &#123;&#125; 3.表单的受控组件和非受控组件 受控组件将 value 值放入到 state 中 添加 value 和 onChange 可实现双向绑定 onChange 与 onInput 事件一致，分别基于 React.ChangeEvent 和 React.FormEvent 12345678910111213141516state = &#123; inputValue: ''&#125;;inputChange = (e) =&gt; &#123; this.setState(&#123; inputValue: e.target.value &#125;);&#125;;render() &#123; return ( &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.inputChange&#125; /&gt; &#123;this.state.inputValue&#125; &lt;/div&gt; );&#125; 4.使用 ref 操作 dom 样式12345678910111213141516171819// react使用current获取当前元素dom节点state = &#123; myRef: React.createRef()&#125;;componentDidMount() &#123; const myRef = this.state.myRef; myRef.current.style.color = 'red';&#125;&lt;div ref=&#123;this.state.myRef&#125;&gt;666&lt;/div&gt;// vue使用value获取当前元素dom节点const myRef=ref()onMounted(() =&gt; &#123; myRef.value.style.color='red'&#125;)&lt;div ref='myRef'&gt;666&lt;/div&gt;return &#123; testRef&#125; 5.生命周期 constructor()：初始化 state 或进行方法绑定时需要 getDerivedStateFromProps(nextProps)：可获取父组件异步传递给子组件的数据 render()：唯一必须实现的方法 componentDidMount()：组件挂载后调用 shouldComponentUpdate()：返回 false，则不会调用 render() getSnapshotBeforeUpdate：更新前调用 componentDidUpdate()：更新后调用 componentWillUnmount()：组件卸载前调用 12345state = &#123;&#125;static getDerivedStateFromProps(nextProps)&#123; console.log(nextProps); return null&#125; 6.父子组件通信 子组件接收父组件参数和方法：通过 props 接收，可设置类型和默认值 父组件接收子组件参数和方法：$refs 不推荐使用，可通过回调函数的方式获取子组件的引用 12345678910111213141516// 父组件import ChildCom from './ChildCom';componentDidMount() &#123; console.log(this.childRef);&#125;render() &#123; return ( &lt;div&gt; &lt;ChildCom onRef=&#123;(ref) =&gt; (this.childRef = ref)&#125; /&gt; &lt;/div&gt; );&#125;// 子组件componentDidMount()&#123; this.props.onRef(this)&#125; 7.使用 prop-types 进行类型检测123456789import PropTypes from 'prop-types'export default class ChildCom extends Component &#123;&#125;ChildCom.propTypes = &#123; name: PropTypes.string.isRequired&#125;// 设置默认值之后，可不用传参，校验不会报错ChildCom.defaultProps = &#123; name: 'Stranger'&#125; 8.Hooks 版本至少是 16.8.0 不用编写 class，在无需修改组件结构的情况下复用状态逻辑 useState：在函数组件中使用 state useRef：在函数组件中使用 refs useContext：在函数组件中使用 context useEffect：替代 class 组件中的生命周期 useMemo：可以实现类似 vue 中 computed 的功能 9.React-Router 安装依赖：yarn add react-router-dom 12345678910111213141516171819// 两个特殊url需要重定向，找不到的url跳转到notFountReactDOM.render( &lt;Router&gt; &lt;Switch&gt; &lt;Redirect exact from=\"/\" to=\"/login\" /&gt; &lt;Redirect exact from=\"/admin\" to=\"/admin/dashboard\" /&gt; &lt;Route path=\"/admin\" render=&#123;(routeProps) =&gt; &lt;Layout &#123;...routeProps&#125; /&gt;&#125; /&gt; &#123;mainRoutes.map((route) =&gt; &#123; return &lt;Route key=&#123;route.path&#125; &#123;...route&#125; /&gt; // return &lt;Route key=&#123;route.path&#125; path=&#123;route.path&#125; component=&#123;route.component&#125; /&gt; &#125;)&#125; &lt;Redirect to=\"/notFount\" /&gt; &lt;/Switch&gt; &lt;/Router&gt;, document.getElementById('root'))// 路由跳转，需要使用withRouter包裹组件，才可以获取到this.props.historyonClick=&#123;() =&gt; this.props.history.push('/admin/dashboard')&#125; 10.Mobx 官方文档 中文文档加载很慢 装饰器在 mobx6 中已被移除，必须使用 makeAutoObservable 来绑定 this 安装依赖：yarn add mobx mobx-react 通过 props 多层组件间传参会比较麻烦，可只在需要的组件内直接引入，此时会增加单元测试的复杂度 类似 redux 在根组件上挂载 store 时，只能获取数据，无法获取函数方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// store/index.jsimport &#123; makeAutoObservable, autorun &#125; from 'mobx'import axios from 'axios'class Store &#123; // 等价于vuex中的state count = 1 price = 10 constructor() &#123; makeAutoObservable(this) &#125; // 等价于vuex中的mutations incrementCount() &#123; this.count++ &#125; incrementPrice() &#123; this.price++ &#125; setCount() &#123; this.count = 10 &#125; // 等价于vuex中的getters get total() &#123; return this.count * this.price &#125; // 等价于vuex中的actions，使用ES6中的generator生成器 *getFlowData() &#123; // 该接口请求不需要考虑跨域问题 yield axios.get('https://dog.ceo/api/breeds/image/random').then((res) =&gt; &#123; console.log(res.data) this.setCount() &#125;) console.log('请求之后打印') &#125;&#125;const store = new Store()// 等价于vue中的watch，监听count变化则打印autorun(() =&gt; &#123; console.log('count:', store.count)&#125;)export default store// 页面中调用import &#123; observer &#125; from 'mobx-react'import store from './storeexport default observer(App) 11.Redux 安装依赖：yarn add redux react-redux 通过高阶组件的方法，使得在组件内部可以通过 this.props 获取 store 内的属性和方法 在 class 组件内通过 get 可以实现类似 vue 中的 computed 高阶组件：接收一个组件作为参数并返回一个新组件的函数 12345678910111213141516171819202122const mapStateToProps = (state) =&gt; &#123; return &#123; ...state &#125;&#125;const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; incrementCount(msg) &#123; dispatch(&#123; type: 'incrementCount', msg &#125;) &#125;, incrementPrice() &#123; dispatch(&#123; type: 'incrementPrice' &#125;) &#125; &#125;&#125;// 高阶组件export default connect(mapStateToProps, mapDispatchToProps)(index) 12.高阶函数 接收的参数是一个函数，或调用的返回值是一个函数 如 promise，setTimeout，setInterval，部分闭包(节流，防抖，函数柯里化等)，数组中的一些迭代器 map 等 13.装饰器 定义：一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上 14.模板 地址：https://github.com/xuya227939/tristana","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}],"keywords":[]},{"title":"vue","slug":"vue","date":"2020-10-31T16:00:00.000Z","updated":"2021-11-27T00:52:27.345Z","comments":true,"path":"2020/11/01/vue/","link":"","permalink":"http://yoursite.com/2020/11/01/vue/","excerpt":"vue 使用","text":"vue 使用 1.在子组件中获取父组件异步请求数据 在 template 中可以正常显示，但是在生命周期中无法打印 需要使用 watch 监听数据的变化 对象内部属性的改变可以添加 deep 设置深度监听 react 中可使用 getDerivedStateFromProps 生命周期函数获取 1234567watch: &#123; doctor: &#123; handler: 'formatData', immediate: true, deep: true &#125;,&#125; 2.元素书写顺序 import name components props data computed watch lifecycle methods 3.父子组件生命周期打印顺序 只有 data 里的变量改变并且要在页面重新渲染完成之后才会调用 beforeUpdate 和 updated 12345678910111213141516father beforeCreatefather createdfather beforeMountchild beforeCreatechild createdchild beforeMountchild mountedfather mountedchild beforeUpdatechild updatedfather beforeUpdatefather updatedfather beforeDestorychild beforeDestorychild destoryedfather destoryed 4.路由跳转后，滚动条回到顶部1234// main.jsrouter.afterEach((to, from, next) =&gt; &#123; window.scrollTo(0, 0)&#125;) 5.无法检测到数组变化1234567891011data: &#123; return&#123; items: [\"a\", \"b\", \"c\"], &#125;&#125;,this.items[1] = \"x\";this.items.length = 2;//替换this.items.splice(index, 1, value);this.items.splice(2); 6.对象属性无法响应式 响应式的对象属性必须已经存在 表格数据新加的列属性要提前定义，否则数据改变视图不会更新 123456this.union = &#123;&#125;//更改为this.union = &#123; name: '', text: ''&#125; 7.在 vue 项目中的 css 下设置背景图片 无法使用@img 当打包之后背景图片无法在 img 文件夹下找到时，是因为 vue 会默认将小图片转成 base64 1background-image: url('../../../assets/img/Information-box.png'); 8.nextTick 的使用场景 在 created/mounted 生命周期函数中获取 dom 元素 在元素被修改后，需要立即获取当前 dom 元素 nextTick 先尝试使用 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替 9.vant 移动端适配 内联样式不会自动转 rem rootValue 或 viewportWidth 的值不建议修改，否则 vant 组件的大小也会随之变化 12345678910111213141516171819202122232425262728293031323334353637383940// rem// 安装插件cnpm i postcss-pxtorem lib-flexible -D// 配置postcss.config.js，若没有该文件可新增该文件module.exports = &#123; plugins: &#123; autoprefixer: &#123; browsers: ['Android &gt;= 4.0', 'iOS &gt;= 8'], &#125;, 'postcss-pxtorem': &#123; rootValue: 37.5, propList: ['*'], &#125;, &#125;,&#125;;// 在main.ts文件中还需要引入import \"lib-flexible/flexible\"// viewport适配// 安装插件cnpm i postcss-px-to-viewport -D// 配置vue.config.js，若没有该文件可新增该文件const autoprefixer = require(\"autoprefixer\");const pxtoviewport = require(\"postcss-px-to-viewport\");module.exports = &#123; outputDir: \"dist\", publicPath: process.env.NODE_ENV === \"production\" ? \"/vant-demo/\" : \"/\", css: &#123; loaderOptions: &#123; postcss: &#123; plugins: [ autoprefixer(), pxtoviewport(&#123; viewportWidth: 375 &#125;) ] &#125; &#125; &#125;&#125;; 10.keep-alive 的使用 定义 两个 vue 文件，使用 keep-alive 包裹它们 在两个路由之间不停切换，查看生命周期的运行情况 可知路由第一次进入时会被缓存，再次进入生命周期函数不会被执行 合理利用 keep-alive 可以减少页面请求 12345678910111213141516171819202122232425262728// 第一次输出，初始进入beforeCreatecreatedbeforeMountmountedactivatedbeforeUpdateupdated// 第二次输出beforeCreate2created2beforeMount2deactivatedmounted2activated2beforeUpdatebeforeUpdate2updated2updated// 第三次输出deactivated2activated// 第四次输出deactivatedactivated2 11.refs 与使用原生方法获取 dom 元素的区别 相对于原生 js 直接获取 dom 元素，ref 获取的是虚拟的 dom，可以有效减少性能消耗 通过 ref 可以直接调用子组件内部的方法或数据 在 mounted 生命周期内获取元素时，需要使用 this.$nextTick 来确保 dom 已经更新完毕 12.父子组件参数和方法的传递 子组件接收父组件参数和方法：props 父组件接收子组件参数和方法：this.$emit(参考 react，可以使用 props 的回调函数) 123456789101112// Child.vueprops: ['fn'],data() &#123; return &#123;&#125;&#125;,mounted() &#123; this.fn(this) this.$emit('emitFn', this)&#125;// index.vue如同react，可以使用回调函数&lt;Child :fn=\"(msg) =&gt; (this.childRef = msg)\" @emitFn=\"emitFn\" /&gt; 13.执行过程 使用 new Vue 初始化，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data，props，computed，watcher 等 Vue 是用 function 实现的类，new Vue 的时候生成实例化对象，拥有 Vue 原型上的属性和方法，并将 this 指针指向该实例化对象 通过$mount 将实例去挂载到 dom 元素上，再通过 render 函数生成虚拟 dom 树 VNode 渲染过程中的数据会通过 getter 被 Watcher 收集，若数据发生变化，会通知 Watcher 执行回调函数，再通过 updata 来把 VNode 渲染成真实的 dom 若存在 template，会将 template 编译成 render 方法，若存在 jsx，同样会被编译成 render 方法 在 render 方法内部通过返回 createElement 来创建元素生成虚拟 dom 树，通过 VNode 这个 class 去定义 14.响应式原理 通过 Object.defineProperty 给实例对象的所有属性添加 setter 和 getter 方法，getter 来进行依赖收集，setter 进行通知更新 在组件的渲染过程中，通过 watcher 进行依赖的收集，当依赖项的 setter 触发时，会通知 watcher，然后将 watcher 添加到队列中，在 nextTick 之后将关联的组件进行更新 弊端：对象不存在的属性无法被监听，数组在利用索引来修改值，或者修改长度的时候也不会被监听，当对象嵌套的层级比较深时，递归遍历性能不好 15.vuex 相比全局变量来说，vuex 中的 state 是响应式的，且可以保存异步数据，单向数据流 mutations 中同样可以执行异步操作，使用 actions 便于使用 devtools 调试时，更好的追踪数据的状态变化 16.vue3.0 变化 响应式变化改用 Proxy 使用高阶组件而不是构造函数来初始化 app 选项式 api 改为组合式 api 使用 hooks 可以更好的状态复用 17.vue 与 react 的异同 相同点：组件化，事件驱动，虚拟 DOM，全局状态管理 不同点：react 需要手动调用 setState 来更新页面，vue 的 api 和约束 更多 实际开发中 vue 项目过大时，修改代码后热加载很慢，且容易产生内存泄漏导致在热加载时启动失败 18.自定义组件 通过 props 暴露参数配置 通过$emit\b 暴露事件 通过动态 class 设置样式 19.微前端 qiankun","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[]},{"title":"javascript","slug":"javascript","date":"2020-09-30T16:00:00.000Z","updated":"2021-08-26T07:03:08.866Z","comments":true,"path":"2020/10/01/javascript/","link":"","permalink":"http://yoursite.com/2020/10/01/javascript/","excerpt":"javascript 基础","text":"javascript 基础 1.基本组成 核心(ECMAScript)，标准兼容 文档对象模型(DOM)，部分不兼容 浏览器对象模型(BOM)，没有相关标准 2.数据类型 Null：空值 Undefined：未定义，包括定义未赋值 Boolean：布尔值 Number：数值，包括 NaN String：字符串 Symbol：浮点数 BigInt：大整数，大于 2^53 - 1 Object：对象，包括 null Array：数组 Math：数学 Date：日期 RegExp：正则 Function：函数 3.Number .toString()：数值转字符串，可用于将 10 进制转换为其他进制，null 和 undefined 无法被转换，可使用 String() .toFixed()：截取数值小数位 isFinite()：判断是否超过了范围 isNaN()：判断是否为非数值 isInteger()：判断是否为整数 parseInt()：字符转成整数，可用于将其他进制转换为 10 进制 parseFloat()：字符转成浮点数 Number()：字符转成数值 4.String .length：字符串长度 .slice()：切开(起始位置，结束位置) .split(“”)：分割成字符串数组 .replace()：字符替换 .match()：匹配的结果 .search()：首次匹配项的索引 .trim()：删除两端空白字符 .toUpperCase()：字符串转为大写 .toLowerCase()：字符串转为小写 .includes()：搜索子字符串，区分大小写 .indexOf()：顺序查找某个元素在字符串中的索引 .lastIndexOf()：逆序查找某个元素在字符串中的索引 .charCodeAt()：字符串中 index 位置的 ASCII 字符编码 .charAt()：获取在指定 index 的字符，功能同[index] .concat()：连接字符串 .substr()：获取从指定位置开始，到指定长度的字符串 .substring()：获取从指定位置开始，到指定位置结束的字符串 5.Object .isPrototypeOf()：表示指定的对象是否在本对象的原型链中 .hasOwnProperty()：表示某个对象是否含有指定的属性，而且此属性非原型链继承的 .toString()：将当前对象以字符串的形式返回 Object.assign()：通过复制一个或多个对象来创建一个新的对象 Object.create()：使用指定的原型对象和属性创建一个新对象 Object.defineProperty()：给对象添加一个属性并指定该属性的配置 Object.defineProperties()：给对象添加多个属性并分别指定它们的配置 Object.freeze()：冻结对象：其他代码不能删除或更改任何属性 Object.getPrototypeOf()：返回指定对象的原型对象 Object.is(value1, value2)：比较两个值是否相同 Object.prototype.toString.call()：检测一个对象的类型 Object.keys()：键 Object.values()：值 Object.entries()：键值对 6.Array 修改原数组 .push()：添加元素到数组的末尾，返回值是新数组的长度 .pop()：删除数组末尾的元素，返回值是移除的数组元素 .shift()：删除数组头部的元素，返回值是移除的数组元素 .unshift()：添加到数组的头部，返回值是新数组的长度 .splice()：删除（开始，长度，元素），返回值是移除的数组元素 .sort()：将数组中元素按 ASCII 码排序 .reverse()：将数组中的元素颠倒顺序 .copyWithin()：复制（目标位置，起始位置，结束位置），浅复制数组的一部分到同一数组中的另一个位置 .fill()：填充（填充的值，起始位置，结束位置），用一个固定值填充一个数组中从起始索引到终止索引内的全部元素 循环数组 .keys()：键 .values()：值 .entries()：键值对 .forEach()：遍历数组，不能响应 break、continue 和 return 语句 .map()：返回新数组 .filter()：返回新的调用数组的子集 .every()：数组的逻辑判定，每一项都返回 true，则返回 true .some()：数组的逻辑判定，有一项都返回 true，则返回 true .reduce()：从第一项开始，向后遍历 .reduceRight()：从最后一项开始，向前遍历 其他 .slice()：切开(起始位置，结束位置)，返回新数组 .concat()：连接数组，返回新数组 .join(“”)：组合数组元素，生成字符串，默认逗号分隔 .length：返回数组长度 .find()：返回数组中满足的第一个元素的值 .findIndex()：返回数组中满足的第一个元素的索引 .indexOf()：从数组开头向后查找 .lastIndexOf()：从数组尾部向前查找 .flat()：数组扁平化 .includes() ：判断一个数组是否包含一个指定的值 .toString() ：返回对应字符串 Array()：创建指定长度，元素为 empty 的数组，也可指定数组内元素 Array.of()：创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型 Array.from()：从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例 Array.isArray()：判断变量是否为数组 7.Math Math.min()：返回一组数中的最小值 Math.max()：返回一组数中的最大值 Math.ceil()：向上取整 Math.floor()：向下取整 Math.round()：四舍五入 Math.abs()：绝对值 Math.random()：大于等于 0 小于 1 的随机数 Math.pow()：基数的指数次幂 Math.sqrt()：开方 8.Date .getFullYear()：年份 .getMonth()：月份 +1 .getDate()：天数 .getDay()：星期 +1 .getHours()：小时 .getMinutes()：分钟 .getSeconds()：秒钟 .getTime()：格林威治时间 new Date()：当前时间 Date.now()：自 1970 年 1 月 1 日到当前时间的毫秒数 Date.UTC()：自 1970 年 1 月 1 日到指定时间的毫秒数 9.RegExp ?：匹配 0 次或 1 次{0,1} *：匹配 0 次或多次{0,} +：匹配一次或多次{1,} \\d：匹配数字[0-9] \\D：匹配非数字[^0-9] \\w：匹配字母数字下划线[A-Za-z0-9_] \\W：匹配非字母数字下划线[^a-za-z0-9_] \\s：匹配空白字符 \\S：匹配非空白字符 /g：全局匹配 /i：不区分大小写匹配 regexObj.exec(str)：在字符串中运行查找，并返回该查找结果的一个数组或 null regexObj.test(str)：返回一个 Boolean 值，它指出在被查找的字符串中是否存在 str.match(regexp)：对字符串执行查找，并将包含查找的结果作为数组返回 str.search(regexp)：返回与正则表达式查找内容匹配的第一个子字符串的位置 str.replace(regexp, newSubStr)：对搜索到的内容用指定的字符串替换 10.DOM childNodes：IE9 以下使用 nodeType：节点类型 children：子节点 parentNode：父节点 offsetParent：获取定位父级 firstChild：IE9 以下使用 firstElementChild：首节点 lastChild：IE9 以下使用 lastElementChild：尾节点 nextSibling：IE9 以下使用 nextElementSibling：后一个兄弟节点 previousSibling：IE9 以下使用 previousElementSibling：前一个兄弟节点 getAttribute(名称)：获取元素属性 setAttribute(名称，值)：设置元素属性 removeAttribute(名称)：删除元素属性 removeChild(节点)：删除一个节点 createElement(标签名)：创建一个节点 appendChild(节点)：追加一个节点 insertBefore(节点，原有节点)：在已有元素前插入 11.BOM window.alert：弹出对话框 window.confirm：弹出对话框 window.prompt：弹出输入框 window.open：打开一个新的浏览器窗口 window.close：关闭浏览器窗口 setTimeout：超时调用 clearTimeout：清除超时调用 setInterval：间歇调用 clearInterval：清除间歇调用 location.href：返回当前加载页面的完整 URL location.hash：返回 URL 中的 hash location.host：返回服务器的名称和端口号 location.hostname：返回服务器的名称 location.pathname：返回 URL 中的目录和文件名 location.port：返回服务器的端口号 location.protocol：返回页面使用的协议 location.search：返回 URL 的查询字符串 location.reaplace：重新定向 URL location.reload：重新加载当前页面 history.back：返回历史记录的上一步 history.forward：返回历史记录的下一步 history.go(-n)：返回历史记录的前 n 步 history.go(n)：返回历史记录的后 n 步 screen.availWidth：返回可用的屏幕宽度 screen.availHeight：返回可用的屏幕高度 UserAgent：用来识别浏览器的名称，版本，引擎以及操作系统等信息 12.元素位置与大小 offsetLeft：元素外边框距离父元素的左内边框的距离 offsetTop：元素外边框距离父元素的上内边框的距离 offsetWidth：获取元素宽度 = width + padding + border offsetHeight：获取元素高度 clientWidth: 获取元素宽度 = width + padding, 不包含滚动部分 clientHeight: 获取元素高度 scrollHeight: 在没有滚动条时，元素内容的高度 scrollWidth: 在没有滚动条时，元素内容的宽度 scrollLeft: 被隐藏在内容区域左侧的宽度(有横向滚动条时) scrollTop: 被隐藏在内容上边区域的高度(有竖向滚动条时) 13.键盘鼠标事件 onkeydown：在用户按下一个键盘按键时发生 onkeypress：在键盘按键被按下并释放一个键时发生 onkeyup：在键盘按键被松开时发生 keyCode：获取按下的键盘按键的字符代码 onload：页面加载时触发 onclick：对象被点击时触发 onmouseover：鼠标滑过时触发 ommouseout：鼠标离开时触发 onmouseup：鼠标按键被松开时触发 onmousemove：鼠标在对象上移动时触发 onmousedown：鼠标按键被按下时触发 onfoucs：获得焦点时触发 onblur：失去焦点时触发 onchange：域的内容改变时触发 onsubmit：表单中的确认按钮被点击时触发 onresize：调整浏览器窗口的大小时触发 onscroll：拖动滚动条滚动时触发 14.其他 encodeURIComponent()：转义除了字母、数字、(、)、.、!、~、*、’、-和_之外的所有字符 decodeURIComponent()：解码","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"keywords":[]},{"title":"deploy","slug":"deploy","date":"2020-08-31T16:00:00.000Z","updated":"2021-11-02T06:39:21.817Z","comments":true,"path":"2020/09/01/deploy/","link":"","permalink":"http://yoursite.com/2020/09/01/deploy/","excerpt":"vue 自动化部署","text":"vue 自动化部署 1.基本环境 云服务器：centos7 终端连接：ssh root@公网 ip mac 连接工具：finalshell windows 连接工具：xshell6 ftp 工具：FileZilla 反向代理：nginx 进程管理：pm2 2.基本命令 查看本机 ip：ipconfig 检查网络是否连通成功：ping xxx.xx.xxx.xxx(服务器 ip) 检查域名是否解析成功：ping xx.xxxxxx.cn(域名) 检查某个端口服务是否开启：telnet www.baidu.com 80(若关闭 nginx，则无法连接通) 查看服务器开启的端口：netstat -ntpl 关闭开启的端口：kill -9 xxxxx 查看硬盘容量：fdisk -l | grep Disk 查看内存：free -h 安装基本依赖：yum -y install gcc pcre-devel zlib-devel openssl openssl-devel 3.安装 nginx 下载安装包：nginx-1.20.1.tar.gz 解压之后通过 ftp 工具放入/usr/local 目录下 进入解压之后的文件夹 nginx-1.20.1 依次运行命令生成 nginx 可启动文件：./configure –with-http_ssl_module(配置 https 需要该模块)，make &amp;&amp; make install 输入./configure 报错：权限不够，执行 chmod +x configure 输入./configure 报错：Permission denied(无权限)，命令前加上 bash 停止 nginx：/usr/local/nginx/sbin/nginx -s stop 启动 nginx：/usr/local/nginx/sbin/nginx (-s reload) 若端口被占用，可重启该端口，或先关闭该端口再启动 修改 nginx 配置后直接重启即可，不需要先关闭 若关闭 nginx，再重启会报错：[error] open() “/run/nginx.pid” failed (2: No such file or directory) 可先执行 nginx 之后再执行重启命令 默认配置 nginx 文件位置：/etc/nginx nginx 版本过低在执行 make &amp;&amp; make install 命令时会报错 配置全局 nginx 环境变量：ln /usr/local/nginx/sbin/nginx /usr/local/bin/nginx 4.安全组和防火墙 安全组必须添加 80 端口，否则 nginx 正常启动但是通过服务器地址无法访问 当项目在其他端口启动时，同样需要在安全组添加相应的端口 防火墙必须要关闭，否则通过服务器地址无法访问 查看：systemctl status firewalld 关闭：systemctl stop firewalld 启动：systemctl start firewalld 5.启动 vue 项目生成的 dist 文件夹 将 dist 文件夹下的内容拷贝到/usr/local/nginx/html 目录下即可 浏览器输入服务器地址即可访问，默认 80 端口 6.全局安装 node 环境 在目录/usr/local 下新建目录 node 并进入 下载 node 压缩包：wget https://nodejs.org/dist/v14.17.4/node-v14.17.4-linux-x64.tar.xz 进入 node 目录，解压 node：tar -xvf node-v14.17.4-linux-x64.tar.xz 配置全局 node 环境变量：ln -s /usr/local/node/node-v14.17.4-linux-x64/bin/node /usr/local/bin/node 配置全局 npm 环境变量：ln -s /usr/local/node/node-v14.17.4-linux-x64/bin/npm /usr/local/bin/npm 安装 yarn：npm i yarn -g 配置全局 yarn 环境变量：ln -s /usr/local/node/node-v14.17.4-linux-x64/bin/yarn /usr/local/bin/yarn 此时可执行 node -v，npm -v，yarn -v 查看版本号 切换 cnpm：npm install -g cnpm –registry=https://registry.npm.taobao.org 配置全局 cnpm 环境变量：ln -s /usr/local/node/node-v14.17.4-linux-x64/bin/cnpm /usr/local/bin/cnpm 7.安装 pm2 全局安装 pm2：npm i pm2 -g 配置全局 pm2 环境变量：ln -s /usr/local/node/node-v14.17.4-linux-x64/bin/pm2 /usr/local/bin/pm2 此时可执行 pm2 -v 查看版本号 查看启动的应用程序：pm2 list 到项目根目录下启动并实时监听改动：pm2 start npm –name “tijian” – run start –watch 关闭所有：pm2 stop all 删除所有：pm2 delete all 重启所有：pm2 restart all 8.启动 nuxt 项目 在根目录下新建 project 目录，进入之后再新建 tijian 目录 拷贝.nuxt nuxt.config package static(内含 favicon.ico 图标) 安装依赖 npm/cnpm i 启动：npm run start 使用 pm2 启动：pm2 start npm –name “nuxt-tijian” – run start –watch 9.通过命令删除文件夹 通过 ftp 删除 node_modules 很慢 可通过命令删除：rm node_modules -rf 10.nginx 配置为 https server 必须为 localhost:3000，保持与项目启动地址一致，不可使用 127.0.0.1:3000 需要.pem 和.key 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243upstream tjnuxt &#123; server localhost:3000; keepalive 64; &#125; server &#123; listen 443 ssl; server_name tijian.eshebao.cn; ssl_certificate 1683959__eshebao.cn.pem; ssl_certificate_key 1683959__eshebao.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; proxy_set_header X-Nginx-Proxy true; proxy_cache_bypass $http_upgrade; proxy_pass http://tjnuxt; #反向代理 &#125; &#125; server &#123; listen 443 ssl; server_name user.eshebao.cn; ssl_certificate 1683959__eshebao.cn.pem; ssl_certificate_key 1683959__eshebao.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; root /project/user; index index.html index.htm; &#125; &#125;&#125; 11.将 http 重定向到 https123456789101112# HTTP server 对http重定向到httpsserver &#123; listen 80; server_name tijian.eshebao.cn; rewrite ^(.*)$ https://tijian.eshebao.cn permanent;&#125;server &#123; listen 80; server_name user.eshebao.cn; rewrite ^(.*)$ https://user.eshebao.cn permanent;&#125; 12.设置静态路径，访问 img，pdf，mp4 等123location /static &#123; alias /static;&#125; 13.添加域名解析 进入域名-&gt;解析-&gt;新手引导/添加记录；输入公网 ip 地址 14.请求代理123location /api/ &#123; proxy_pass http://music.163.com;&#125; 15.history 模式12345location / &#123; try_files $uri $uri/ /index.html; root /project/user; index index.html index.htm;&#125; 16.nuxt 项目加 robots 防爬虫 将 robots 文件放入 static 文件夹之下，获取 static 文件夹内的内容使用/文件名 17.使用 github 的 webhook 实现自动部署 进入 github，找到需要自动部署的项目，添加 webhook 输入请求 url：http://公网 IP:8888/webhook(必须在云服务器安全组开启对应端口) 输入 secret 密码，每次 push 可在 deliveries 中看到请求 url 是否执行成功 npm init 创建 package.json，安装依赖包 npm install github-webhook-handler –save 进入/project 目录，通过 ssh 连接来拉取 github 仓库代码，git clone ssh 链接 新建文件夹，新建 ci.sh 文件，并写入脚本 1234cd /project/try-vue // 进入项目目录git pullcnpm installnpm run build 新建 index.js，使用 node index.js 或 pm2 start index.js –name “webhook” – run start –watch 来启动 node 服务 123456789101112131415161718192021222324252627282930313233343536373839404142var http = require('http')var createHandler = require('github-webhook-handler')var &#123; exec &#125; = require('child_process') //node中子进程调用文件模块var handler = createHandler(&#123; path: '/webhook', secret: 'XXX'&#125;)http .createServer(function (req, res) &#123; handler(req, res, function (err) &#123; res.statusCode = 404 res.end('no such location') &#125;) &#125;) .listen(8888)handler.on('error', function (err) &#123; console.error('Error:', err.message)&#125;)handler.on('push', function (event) &#123; console.log('Received a push event for %s to %s', event.payload.repository.name, event.payload.ref) // 执行`sh ci.sh`命令 exec('sh ci.sh', (err, stdout, stderr) =&gt; &#123; if (err) &#123; console.error(err) return &#125; console.log(stdout) &#125;)&#125;)handler.on('issues', function (event) &#123; console.log( 'Received an issue event for %s action=%s: #%d %s', event.payload.repository.name, event.payload.action, event.payload.issue.number, event.payload.issue.title )&#125;) 18.nginx 配置 gzip 压缩12gzip on;gzip_types text/plain application/javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; 19.安装 jdk 环境 jdk 所在文件目录：/usr/local/java/jdk1.8.0_281 设置环境变量，并使之生效：source /etc/profile 查看是否配置成功：java -version 123456// /etc/profile 在unset -f pathmunge该行下添加环境变量export JAVA_HOME=/usr/local/java/jdk1.8.0_281export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib:$CLASSPATHexport JAVA_PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/binexport PATH=$PATH:$&#123;JAVA_PATH&#125; 20.安装 Jenkins 启动 jenkins：systemctl start jenkins 停止 jenkins：systemctl stop jenkins 重启 jenkins：systemctl restart jenkins 查看 jenkins 状态：systemctl status jenkins 注意要建立软链接：ln -s /usr/local/java/jdk1.8.0_281/bin/java /usr/bin/java jenkins 的启动会占用较多内存 1234wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.reporpm --import http://pkg.jenkins-ci.org/redhat-stable/jenkins-ci.org.keyyum install jenkinssystemctl start jenkins 21.Jenkins 配置 默认地址端口：http://116.62.124.208:8080 (端口需到安全组添加) 查看密码并填写：cat /var/lib/jenkins/secrets/initialAdminPassword 插件安装失败可直接跳过 安装插件，Locale plugin 插件只能显示繁体中文，需安装 Chinese (Simplified)插件 用户名默认 admin 修改登录密码 git clone 拉取代码太慢：git clone https://github.com.cnpmjs.org/Enjoy-yuan/vue-template.git/ (添加.cnpmjs.org) 22.github 配置 ssh 连接 生成 ssh 密钥：ssh-keygen -t rsa -C 13733443259@163.com 查看密钥：cat /root/.ssh/id_rsa.pub 23.配置 jenkins 环境变量 查看全部环境变量：echo $PATH 否则执行脚本时，yarn，npm 等命令找不到 查看当前路径：pwd shell 执行默认路径：/var/lib/jenkins/workspace/ 需要到 System Configuration 中配置全局属性 12键：path值：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/java/jdk1.8.0_281/bin:/usr/local/java/jdk1.8.0_281/jre/bin:/root/bin 24.shell 无法写入文件 执行 mkdir aaa 时提示：cannot create directory ‘aaa’: Permission denied git clone xxx 也无法执行 找到/etc/sysconfig/jenkins 文件，JJENKINS_USER=”jenkins”中的 jenkins 替换为 root 重启 jenkins 服务：service jenkins restart 25.换 gitlab github 拉取代码太慢且报错，换 gitlab 内存撑满时服务器会死机，需到控制台重启服务器，此时 nginx 也需要重新启动 配置构建 Execute shell 脚本 jenkins 地址：http://116.62.124.208:8080/ 项目地址：https://116.62.124.208/ 在/位置新建 project 文件夹 可以根据不通分支命名不同项目名称，如：vue-template-master，vue-template-dev 等，在 shell 中通过 git checkout 切换分支 1234567891011121314151617// 首先判断项目是否存在，若不存在为初始状态，就先回到根目录，创建并进入project文件夹，然后拉取项目；若存在则直接拉取最新代码，安装依赖，进行打包生成dist文件夹FILE=/project/vue-templateif [ -f \"$FILE\" ]; then echo \"$FILE exist\" cd /project/vue-template git pullelse echo \"$FILE does not exist，git clone\" cd / mkdir project cd /project git clone https://gitlab.com/Enjoy-yuan/vue-template.git cd vue-templatefiyarnyarn build 26.域名备案 会有客服打电话确认信息 网站名称可能不通过：可修改为，个人 WEB 技术分享 具体地址可能不通过：要详细到门牌号 域名解析需要暂时全部关闭，待备案成功再开启 备案需要十天左右，备案成功后添加域名解析，几分钟后即可访问 最终地址：https://yuanchengjs.cn 首屏加载过慢可能是服务器带宽太低 27.新开端口部署 react 项目 将 react 打包之后的 build 文件夹放入到/project/react-template 中 开端口 8081 添加 nginx 配置 访问地址：http://116.62.124.208:8081/ 静态文件服务器不可为 static，会与 react 项目的文件夹冲突 12345678910server &#123; listen 8081; server_name localhost; location / &#123; try_files $uri $uri/ /index.html; root /project/react-template/build; index index.html index.htm; &#125;&#125; 28.配置二级域名 到域名解析中添加主机记录：vue2，vue3，react 微前端的子应用需要在 nginx 中设置域名允许被跨域 二级域名的免费 ssl 证书需要单独申请，用顶级域名的 ssl 证书会提示不安全 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170// nginx.confworker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # gzip on; # 微前端基座 server &#123; listen 80; server_name yuanchengjs.cn; # rewrite ^(.*)$ https://yuanchengjs.cn permanent; location / &#123; try_files $uri $uri/ /index.html; root /project/vue-template/dist; index index.html index.htm; &#125; location /api/ &#123; proxy_pass http://music.163.com; &#125; &#125; # 微前端vue2应用 server &#123; listen 80; server_name vue2.yuanchengjs.cn; # rewrite ^(.*)$ https://vue2.yuanchengjs.cn permanent; location / &#123; try_files $uri $uri/ /index.html; root /project/micro-vue2/dist; index index.html index.htm; &#125; &#125; # 微前端vue3应用 server &#123; listen 80; server_name vue3.yuanchengjs.cn; # rewrite ^(.*)$ https://vue3.yuanchengjs.cn permanent; location / &#123; try_files $uri $uri/ /index.html; root /project/micro-vue3/dist; index index.html index.htm; &#125; &#125; # 单独的react项目 server &#123; listen 80; server_name react.yuanchengjs.cn; # rewrite ^(.*)$ https://react.yuanchengjs.cn permanent; location / &#123; try_files $uri $uri/ /index.html; root /project/react-template/build; index index.html index.htm; &#125; &#125; # HTTPS server server &#123; gzip on; gzip_types text/plain application/javascript text/css application/xml text/javascript image/jpeg image/gif image/png; listen 443 ssl; server_name yuanchengjs.cn; ssl_certificate cert/6039194_yuanchengjs.cn.pem; ssl_certificate_key cert/6039194_yuanchengjs.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; #location /img &#123; # alias /img; #&#125; location / &#123; try_files $uri $uri/ /index.html; root /project/vue-template/dist; index index.html index.htm; &#125; location /api/ &#123; proxy_pass http://music.163.com; &#125; &#125; server &#123; listen 443 ssl; server_name vue2.yuanchengjs.cn; ssl_certificate cert/6394608_vue2.yuanchengjs.cn.pem; ssl_certificate_key cert/6394608_vue2.yuanchengjs.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') &#123; return 204; &#125; try_files $uri $uri/ /index.html; root /project/micro-vue2/dist; index index.html index.htm; &#125; &#125; server &#123; listen 443 ssl; server_name vue3.yuanchengjs.cn; ssl_certificate cert/6394664_vue3.yuanchengjs.cn.pem; ssl_certificate_key cert/6394664_vue3.yuanchengjs.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') &#123; return 204; &#125; try_files $uri $uri/ /index.html; root /project/micro-vue3/dist; index index.html index.htm; &#125; &#125; server &#123; listen 443 ssl; server_name react.yuanchengjs.cn; ssl_certificate cert/6039194_yuanchengjs.cn.pem; ssl_certificate_key cert/6039194_yuanchengjs.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; try_files $uri $uri/ /index.html; root /project/react-template/build; index index.html index.htm; &#125; &#125;&#125; 29.部署在不同的二级目录 相比 访问地址变为：yuanchengjs.cn/base 123456789101112// 修改 src/router/index.jsexport const router = new VueRouter(&#123; mode: 'history', // base: '/', base: '/base/', routes&#125;)// 修改nginx配置// location /location / base 30.nginx 代理接口区别123456789// 实际指向：http://cloud-music.pl-fe.cn/apilocation /api/ &#123; proxy_pass http://cloud-music.pl-fe.cn;&#125;// 实际指向：http://cloud-music.pl-fe.cnlocation /api/ &#123; proxy_pass http://cloud-music.pl-fe.cn/;&#125;","categories":[],"tags":[{"name":"deploy","slug":"deploy","permalink":"http://yoursite.com/tags/deploy/"}],"keywords":[]},{"title":"algorithm","slug":"algorithm","date":"2020-07-31T16:00:00.000Z","updated":"2021-11-18T02:34:00.738Z","comments":true,"path":"2020/08/01/algorithm/","link":"","permalink":"http://yoursite.com/2020/08/01/algorithm/","excerpt":"algorithm","text":"algorithm 1.简单排序123let arr = [4, 3, 5, 2, 1, 8, 7, 9, 6]arr.sort((a, b) =&gt; a - b)console.log(arr) 2.冒泡排序 让当前项和后一项比较，如果当前项大于后一项，两者交换位置 12345678910111213function bubbleSort(arr) &#123; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; let temp = arr[j + 1] arr[j + 1] = arr[j] arr[j] = temp &#125; &#125; &#125; return arr&#125;console.log(bubbleSort([4, 3, 5, 2, 1, 8, 7, 9, 6])) 3.快速排序 在数组中间项作为“基准点”，比基准点小的数值项放到左边，大的放到右边 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 错误写法function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr &#125; let pointIndex = Math.floor(arr.length / 2) //选定数组中间值为基准点 let pointValue = arr.splice(pointIndex, 1)[0] //获取基准点的值 //数组拆分 let left = [] let right = [] for (let i = 0; i &lt; arr.length; i++) &#123; arr[i] &lt; pointValue ? left.push(arr[i]) : right.push(arr[i]) &#125; //递归拆分 return quickSort(left).concat([pointValue], quickSort(right))&#125;console.log(quickSort([4, 3, 5, 2, 1, 8, 7, 9, 6]))// 正确解法let arr = [5, 3, 4, 2, 6, 8, 5, 1, 3, 4, 2, 6, 8, 5]function fn(arr, i, j) &#123; if (i &lt; j) &#123; let left = i let right = j let base = arr[i] while (i &lt; j) &#123; while (base &lt;= arr[j] &amp;&amp; i &lt; j) &#123; j-- &#125; if (i &lt; j) &#123; arr[i++] = arr[j] &#125; while (arr[i] &lt;= base &amp;&amp; i &lt; j) &#123; i++ &#125; if (i &lt; j) &#123; arr[j--] = arr[i] &#125; &#125; arr[i] = base fn(arr, left, i - 1) fn(arr, i + 1, right) &#125;&#125;fn(arr, 0, arr.length - 1)console.log(arr) 4.插入排序 从左到右依次取数组中的项，从后向前依次比较，选择合适位置插入 123456789101112131415161718192021function insertSort(arr) &#123; let newArr = [] newArr.push(arr[0]) //放入第一个值 for (let i = 1; i &lt; arr.length; i++) &#123; for (let j = newArr.length - 1; j &gt;= 0; ) &#123; if (arr[i] &lt; newArr[j]) &#123; j-- //从后向前依次比较 if (j === -1) &#123; newArr.unshift(arr[i]) &#125; &#125; else &#123; newArr.splice(j + 1, 0, arr[i]) j = -1 &#125; &#125; &#125; return newArr&#125;console.log(insertSort([4, 3, 5, 2, 1, 8, 7, 9, 6])) 5.数组去重1234567891011121314151617//方法一let arr = [4, 3, 5, 6, 8, 1, 5, 2, 1, 8, 7, 6, 9]let newArr = Array.from(new Set(arr))// let newArr = [...(new Set(arr))];console.log(newArr)//方法二function unique(arr) &#123; let result = [] for (let i = 0; i &lt; arr.length; i++) &#123; if (result.indexOf(arr[i]) === -1) &#123; result.push(arr[i]) &#125; &#125; return result&#125;console.log(unique([1, 3, 5, 4, 3, 1, 4])) 6.两数交换123456let a = 2let b = 3a = a + bb = a - ba = a - bconsole.log(a, b) 7.找出元素 item 在数组 arr 中的位置1234567891011121314151617function indexOf(arr, item) &#123; if (Array.prototype.indexOf) &#123; return arr.indexOf(item) &#125; else &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] === item) &#123; return i &#125; else &#123; return -1 &#125; &#125; &#125;&#125;let arr = [1, 2, 3, 4, 5, 6]let item = 3let n = indexOf(arr, item)console.log(n) 8.计算给定数组 arr 中所有元素的总和12345678910function sum(arr) &#123; let sum = 0 arr.forEach(function (value) &#123; sum += value &#125;) return sum&#125;let arr = [1, 2, 3, 4, 5, 6]let n = sum(arr)console.log(n) 9.移除数组 arr 中所有与 item 相等的元素，返回新的数组1234567891011function remove(arr, item) &#123; let a = [] for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] !== item) a.push(arr[i]) &#125; return a&#125;let arr = [1, 2, 3, 4, 5, 6]let item = 5let newArr = remove(arr, item)console.log(newArr) 10.移除数组 arr 中所有与 item 相等的元素，并将结果返回12345678910111213function remove(arr, item) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; if (arr[i] === item) &#123; arr.splice(i, 1) i-- &#125; &#125; return arr&#125;let arr = [1, 2, 3, 4, 5, 6]let item = 5remove(arr, item)console.log(arr) 11.实现一个打点计时器，要求如下 1.从 start 到 end，每隔 100 毫秒 consolo.log 一个数字，每次增幅为 1 2.返回的对象中需要包含一个 cancal 方法，用于停止定时操作 3.第一个数需要立即输出 1234567891011121314151617function count(start, end) &#123; console.log(start++) let timer = setInterval(function () &#123; if (start &lt;= end) &#123; console.log(start++) &#125; else &#123; clearInterval(timer) &#125; s &#125;, 100) return &#123; cancel: function () &#123; clearInterval(timer) &#125; &#125;&#125;count(1, 10) 12.实现 fizzBuzz 函数，参数 num 与返回值的关系如下 1.如果 num 能同时被 3 和 5 整除，返回字符串 fizzbuzz 2.如果 num 能被 3 整除，返回字符串 fizz 3.如果 num 能被 5 整除，返回字符串 buzz 4.如果字符串为空或者不是 Number 类型，返回 false 5.其余情况，返回参数 num 12345678910111213function fizzBuzz(num) &#123; if (num % 3 === 0 &amp;&amp; num % 5 === 0) &#123; return 'fizzbuzz' &#125; else if (num % 3 === 0) &#123; return 'fizz' &#125; else if (num % 5 === 0) &#123; return 'buzz' &#125; else if (num === null || typeof num !== 'number') &#123; return false &#125; else return num&#125;let str = fizzBuzz('hello')console.log(str) 13.找出整型数组中乘积最大的三个数12345678910111213let arr = [-1, -2, -3, -4, 0, 1, 2, 3]arr.sort(function (a, b) &#123; return a - b&#125;)function findMax(arr) &#123; let length = arr.length - 1 let max1 = arr[0] * arr[1] * arr[length] let max2 = arr[length] * arr[length - 1] * arr[length - 2] let Max max1 &gt; max2 ? (Max = max1) : (Max = max2) return Max&#125;console.log(findMax(arr)) 14. 寻找连续数组中缺失的数字12345678910111213141516let arr = [-1, -2, -3, -4, 0, 2, 3]arr.sort(function (a, b) &#123; return a - b&#125;)let min = arr[0]let max = arr[arr.length - 1]function findLost(arr) &#123; let sum1 = 0 let sum2 = 0 for (let i = 0; i &lt; arr.length; i++) &#123; sum1 += arr[i] &#125; sum2 = ((min + max) * (max - min + 1)) / 2 return sum2 - sum1&#125;console.log(findLost(arr)) 15.斐波拉契数列1234567891011121314151617181920212223// 普通递归function fn(i) &#123; if (i &lt; 2) &#123; return i &#125; return fn(i - 1) + fn(i - 2)&#125;console.log(fn(10))// 使用动态规划function fn(i) &#123; if (i &lt; 2) &#123; return i &#125; let arr = [] arr[0] = 1 arr[1] = 1 for (let j = 2; j &lt; i; j++) &#123; arr[j] = arr[j - 2] + arr[j - 1] &#125; return arr[i - 1]&#125;console.log(fn(10)) 16.实现移除字符串空格函数 Trim12345678910111213141516171819202122232425262728293031function Trim(str) &#123; let start = 0 let end = 0 //去除左边空格 for (let i = 0; i &lt; str.length; i++) &#123; if (str[i] != ' ') &#123; start = i break &#125; &#125; //去除右边空格 for (let j = str.length - 1; j &gt; 0; j--) &#123; if (str[j] != ' ') &#123; end = j break &#125; &#125; //去除中间超过一个的空格 str = str.slice(start, end + 1) let result = '' for (let k = 0; k &lt; str.length; k++) &#123; if (str[k] === str[k + 1] &amp;&amp; str[k] === ' ') &#123; continue &#125; else &#123; result = result.concat(str[k]) &#125; &#125; return result&#125;let str = ' a bc d 'console.log(Trim(str)) 17.二维数组中的查找 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213141516171819202122function Find(target, array) &#123; let hang = array.length //行的长度 let lie = array[0].length //列的长度 if (hang === 0 &amp;&amp; lie === 0) &#123; return false &#125; //选择起点为二维数组左下角 let i = 0 let j = lie - 1 while (i &lt; hang &amp;&amp; j &gt; -1) &#123; if (array[i][j] &lt; target) &#123; i++ &#125; else if (array[i][j] &gt; target) &#123; j-- &#125; else &#123; return true &#125; &#125; if (i &gt; hang || j &lt; 0) &#123; return false &#125;&#125; 18.替换空格 实现一个函数，将一个字符串中的空格替换成“，” 12345678function replaceSpace(str) &#123; return str.split(' ').join(',')&#125;let string = replaceSpace('I love you')console.log(string)// 使用正则console.log(str.replace(/\\s/g, ',')) 19.跳台阶 一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级；求该青蛙跳上一个 n 级的台阶总共有多少种跳法 12345678910111213141516171819function jumpFloor(n) &#123; let a = 1 let b = 2 let c = 0 if (n === 1) &#123; c = 1 &#125; if (n === 2) &#123; c = 2 &#125; for (let i = 3; i &lt;= n; i++) &#123; c = a + b a = b b = c &#125; return c&#125;let sum = jumpFloor(10)console.log(sum) 20.调整数组顺序使奇数位于偶数前 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变 12345678910111213141516function reOrderArray(array) &#123; let left = [] let right = [] let result = [] for (let i = 0; i &lt; array.length; i++) &#123; if (array[i] % 2 == 0) &#123; right.push(array[i]) &#125; else &#123; left.push(array[i]) &#125; &#125; result = left.concat(right) return result&#125;let newArr = reOrderArray([4, 1, 2, 6, 5, 3, 9, 8, 7])console.log(newArr) 21.数组扁平化1234567891011121314151617181920212223// 数组递归let arr = [1, 2, 3, [4, [5, 6]]]function flatten(arr) &#123; let res = [] ;[].concat( ...arr.map((n) =&gt; &#123; if (Array.isArray(n)) &#123; res = res.concat(flatten(n)) &#125; else &#123; res.push(n) &#125; &#125;) ) return res&#125;console.log(flatten(arr))// 使用flat方法console.log(arr.flat(Infinity))// 转字符串console.log(arr.join().split(','))console.log(arr.toString().split(',')) 22.实现字符串大写转小写 字符转 ASCII 码：.charCodeAt() ASCII 码转字符：String.fromCharCode() 123456789101112let str = 'abcdEGsdkjhsdkEWSAHhjaH'let len = 'a'.charCodeAt() - 'A'.charCodeAt()function fn(str) &#123; let arr = str.split('') for (let key of arr.keys()) &#123; if (arr[key] &gt;= 'A' &amp;&amp; arr[key] &lt;= 'Z') &#123; arr[key] = String.fromCharCode(arr[key].charCodeAt() + len) &#125; &#125; return arr.join('')&#125;console.log(fn(str)) 23.合并两个有序数组12345678910111213141516171819202122let arr1 = [1, 4, 6, 8, 9, 11, 23, 45, 66]let arr2 = [3, 6, 8, 10]let arr3 = []function fn(arr1, arr2) &#123; let i = 0, j = 0 while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) &#123; if (arr1[i] &lt;= arr2[j]) &#123; arr3.push(arr1[i++]) &#125; else &#123; arr3.push(arr2[j++]) &#125; &#125; if (i === arr1.length) &#123; arr3 = arr3.concat(arr2.slice(j)) &#125; else &#123; arr3 = arr3.concat(arr1.slice(i)) &#125;&#125;fn(arr1, arr2)console.log(arr3) 24.将 url 后面的参数转换为对象123456789101112131415161718const str = 'xxx?name=jack&amp;age=22'const newStr = str.slice(str.indexOf('?') + 1) // 获取?后面的字符串const newArr = newStr.split('&amp;') // 分割成数组let newObj = &#123;&#125;newArr.map((item) =&gt; &#123; newObj[item.split('=')[0]] = item.split('=')[1]&#125;)console.log(newObj)// let str = \"http://url/api?param=2&amp;param2=4\";// let index = str.indexOf(\"?\");// let obj = new Object();// let aParams = str.slice(index + 1).split(\"&amp;\");// for (let i = 0; i &lt; aParams.length; i++) &#123;// let aParam = aParams[i].split(\"=\");// obj[aParam[0]] = aParam[1];// &#125;// console.log(obj); 25.将字符串中的大小写字母进行取反1234567891011let str = 'sdhJ2542HSfkjfk89790knKKK'let strArr = str.split('')strArr.map((item, index) =&gt; &#123; if (item &gt;= 'a' &amp;&amp; item &lt;= 'z') &#123; strArr[index] = item.toUpperCase() &#125; else if (item &gt;= 'A' &amp;&amp; item &lt;= 'Z') &#123; strArr[index] = item.toLowerCase() &#125;&#125;)str = strArr.join('')console.log(str) 26.大整数相加1234567891011121314151617181920212223242526272829303132333435363738394041424344let str1 = '11111111111111111111111'let str2 = '1111111111'let str1Arr = str1.split('').reverse()let str2Arr = str2.split('').reverse()let newArr = [] // 数组相加的新数组let i = 0let temp = 0 // 保留的进位值，为0或1// 循环相加while (i &lt; str1Arr.length &amp;&amp; i &lt; str2Arr.length) &#123; let sum = parseInt(str1Arr[i]) + parseInt(str2Arr[i]) + temp if (sum &lt; 10) &#123; newArr.push(sum) temp = 0 &#125; else &#123; newArr.push(sum - 10) temp = 1 &#125; i++&#125;let that = i //保存当前的i值// 将剩余的数组进行拼接if (i === str1Arr.length) &#123; while (i &lt; str2Arr.length) &#123; newArr.push(str2Arr[i]) i++ &#125;&#125; else &#123; while (i &lt; str1Arr.length) &#123; newArr.push(str1Arr[i]) i++ &#125;&#125;// 若还存在进位则对应位置加一if (temp === 1 &amp;&amp; newArr[that] !== undefined) &#123; newArr[that]++&#125;console.log(newArr.reverse().join(''))console.log(parseInt(str1) + parseInt(str2)) 27.一行代码取乱序数组中的最大值123let arr = [1, 22, 23, 42, 34, 5, 2, 42]console.log(arr.sort((a, b) =&gt; b - a)[0])console.log(Math.max(...arr)) 28.找出字符串中连续最大的数123456function findMax(val) &#123; const reg = /\\d+/g const max = Math.max(...val.match(reg)) console.log(max)&#125;findMax('sff9s999sd7fsdg') 29.将单词逆序输出123let str = ' I am Tony 'let newArr = str.split(/\\s+/g).filter((item) =&gt; item)console.log(newArr.reverse().join(' ')) 30.背包问题(动态规划)123456789101112131415161718192021222324252627282930// 01 背包let weight = [2, 3, 4, 5]let value = [3, 4, 5, 6]function fn(weight, value, sumWeight) &#123; let arr = [] for (let i = 0; i &lt; weight.length; i++) &#123; // 设置为二维数组 arr[i] = [] for (let j = 0; j &lt;= sumWeight; j++) &#123; // 第一行作为边界 if (i === 0) &#123; if (j &lt; weight[i]) &#123; arr[i][j] = 0 &#125; else &#123; arr[i][j] = value[i] &#125; &#125; else &#123; if (j &lt; weight[i]) &#123; arr[i][j] = arr[i - 1][j] &#125; else &#123; // 状态转移方程 arr[i][j] = Math.max(arr[i - 1][j], arr[i - 1][j - weight[i]] + value[i]) &#125; &#125; &#125; &#125; console.log(arr[weight.length - 1][sumWeight]) return arr&#125;console.log(fn(weight, value, 10)) 31.不同路径问题(动态规划)12345678910111213141516171819function fn(m, n) &#123; let arr = [] for (let i = 0; i &lt; m; i++) &#123; arr[i] = [] for (let j = 0; j &lt; n; j++) &#123; // 第一行和第一列作为边界 if (j === 0) &#123; arr[i][j] = 1 &#125; else if (i === 0) &#123; arr[i][j] = 1 &#125; else &#123; // 状态转移方程 arr[i][j] = arr[i - 1][j] + arr[i][j - 1] &#125; &#125; &#125; return arr&#125;console.log(fn(3, 7)) 32.10 进制转 16 进制12345678910111213141516171819202122232425// 使用 parseInt 可用于将其他进制转换为 10 进制let num = 123456let arr = []while (num &gt;= 16) &#123; arr.unshift(num % 16) num = Math.floor(num / 16)&#125;arr.unshift(num)let newArr = arr.map((item) =&gt; &#123; if (item === 10) &#123; return 'a' &#125; else if (item === 11) &#123; return 'b' &#125; else if (item === 12) &#123; return 'c' &#125; else if (item === 13) &#123; return 'd' &#125; else if (item === 14) &#123; return 'e' &#125; else if (item === 15) &#123; return 'f' &#125; else return item&#125;)console.log(newArr.join(''))console.log((123456).toString(16)) 33.两小数相乘123456789let a = 1.103873let b = 1.287338let aLen = a.toString().length - 1let aLenPoint = a.toString().indexOf('.')let bLen = b.toString().length - 1let bLenPoint = b.toString().indexOf('.')console.log( (a * Math.pow(10, aLen - aLenPoint) * (b * Math.pow(10, bLen - bLenPoint))) / Math.pow(10, aLen - aLenPoint + bLen - bLenPoint)) 34.保留两位小数，隔三个数加逗号12345678910111213141516171819function fn(num) &#123; let arr = num.toFixed(2).toString().split('') let newArr = [] let index = 1 for (let i = arr.length - 4; i &gt;= 0; i--) &#123; newArr.push(arr[i]) if (index % 3 === 0) &#123; newArr.push(',') &#125; index++ &#125; newArr.reverse() if (newArr[0] === ',') &#123; newArr.shift() &#125; return newArr.concat(arr.slice(-3)).join('')&#125;console.log(fn(4232123567.88)) 35.查找字符串数组的最长公共前缀12345678910111213141516171819let arr = ['flower', 'flow', 'floight']let fn = (arr) =&gt; &#123; if (arr.length === 0 || arr === null) &#123; return '' &#125; let prevs = arr[0] for (let i = 1; i &lt; arr.length; i++) &#123; let j = 0 for (; j &lt; prevs.length; j++) &#123; if (prevs[j] !== arr[i][j]) &#123; break &#125; &#125; prevs = prevs.slice(0, j) &#125; return prevs&#125;console.log(fn(arr)) 36.求 30 以内的质数123456789101112131415161718192021let arr = []let fn = function (num) &#123; if (num === 1) &#123; return [] &#125; for (let i = 2; i &lt;= num; i++) &#123; let flag = false for (let j = 2; j &lt;= Math.sqrt(i); j++) &#123; if (i % j === 0) &#123; flag = true &#125; &#125; if (flag === false) &#123; arr.push(i) &#125; &#125; return arr&#125;console.log(fn(30)) 37.检查字符串中括号是否平衡匹配12345678910111213141516171819202122232425262728293031323334353637383940414243// let str = \"(2)734()(2348)87243\";// let leftNum = 0;// function fn(str) &#123;// str.split(\"\").map((item) =&gt; &#123;// if (item === \"(\") &#123;// leftNum++;// &#125;// if (item === \")\") &#123;// leftNum--;// &#125;// if (leftNum &lt; 0) &#123;// return false;// &#125;// &#125;);// if (leftNum !== 0) &#123;// return false;// &#125; else &#123;// return true;// &#125;// &#125;// str.charAt(i) 等价于 str[i]let str = '(2)734()(2348)87243'let leftNum = 0function fn(str) &#123; for (let i = 0; i &lt; str.length - 1; i++) &#123; if (str.charAt(i) === '(') &#123; leftNum++ &#125; if (str.charAt(i) === ')') &#123; leftNum-- &#125; if (leftNum &lt; 0) &#123; return false &#125; &#125; if (leftNum !== 0) &#123; return false &#125; else &#123; return true &#125;&#125;console.log(fn(str)) 38.对象数组转树型结构 用于菜单数据结构转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 将一个扁平化的对象数组，转化为树形结构// 现在有一个对象组成的数组，每个元素有id属性和parent_id属性，根据其id属性和parent_id属性，将其转换为树结构的对象const arr = [ &#123; id: '1', parent_id: 'root', name: 'abc' &#125;, &#123; id: '2', parent_id: 'root', name: 'abc' &#125;, &#123; id: '1-1', parent_id: '1', name: 'abc' &#125;, &#123; id: '1-2', parent_id: '1', name: 'abc' &#125;, &#123; id: '1-1-1', parent_id: '1-1', name: 'abc' &#125;, &#123; id: '1-1-2', parent_id: '1-1', name: 'abc' &#125;, &#123; id: '1-2-1', parent_id: '1-2', name: 'abc' &#125;, &#123; id: '2-1', parent_id: '2', name: 'abc' &#125;, &#123; id: '2-2', parent_id: '2', name: 'abc' &#125;, &#123; id: '2-1-1', parent_id: '2-1', name: 'abc' &#125;, &#123; id: '2-2-1', parent_id: '2-2', name: 'abc' &#125;, &#123; id: '2-2-1-1', parent_id: '2-2-1', name: 'abc' &#125;, &#123; id: '2-2-1-2', parent_id: '2-2-1', name: 'abc' &#125;, &#123; id: '2-2-1-2-1', parent_id: '2-2-1-2', name: 'abc' &#125;, &#123; id: '2-3', parent_id: '2', name: 'abc' &#125;, &#123; id: '2-3-1', parent_id: '2-3', name: 'abc' &#125;, &#123; id: '3', parent_id: 'root', name: 'abc' &#125;]let dataToTree = (data) =&gt; &#123; let map = &#123;&#125; let treeData = [] data.map((item) =&gt; &#123; map[item.id] = item &#125;) data.map((item) =&gt; &#123; const parent = map[item.parent_id] if (parent) &#123; if (!Array.isArray(parent.children)) parent.children = [] parent.children.push(item) &#125; else &#123; treeData.push(item) &#125; &#125;) return treeData&#125;console.log(dataToTree(arr)) 39.二分查找123456789101112131415161718192021222324252627282930313233343536373839404142434445// 非递归let arr = [1, 2, 3, 7, 12, 25, 33, 54]let find = (arr, value) =&gt; &#123; let low = 0 let high = arr.length - 1 let middleIndex, middleValue while (low &lt;= high) &#123; middleIndex = Math.floor((low + high) / 2) middleValue = arr[middleIndex] if (middleValue === value) &#123; return middleIndex &#125; else if (middleValue &gt; value) &#123; high = middleIndex - 1 &#125; else &#123; low = middleIndex + 1 &#125; &#125; return -1&#125;console.log(find(arr, 3))console.log(find(arr, 33))console.log(find(arr, 28))// 递归let arr = [1, 2, 3, 7, 12, 25, 33, 54]let find = (arr, value, low = 0, high = arr.length - 1) =&gt; &#123; let middleIndex = Math.floor((low + high) / 2) let middleValue = arr[middleIndex] if (middleValue === value) &#123; return middleIndex &#125; else if (low &gt;= high) &#123; return -1 &#125; else if (middleValue &lt; value) &#123; return find(arr, value, middleIndex + 1, high) &#125; else &#123; return find(arr, value, low, middleIndex - 1) &#125;&#125;console.log(find(arr, 3))console.log(find(arr, 33))console.log(find(arr, 28)) 40.查找字符串中的数值1234// str.match(/\\d+(.\\d+)?/g) 含小数点const str = 'asfs123fasde;lkjjiwdf2;kj;;l;io55fsa'const findNum = (str) =&gt; str.match(/\\d+(.\\d+)?/g)console.log(findNum(str)) 41.三角形最大周长12345678910let arr = [1, 12, 3, 41, 5, 4, 8]let fn = (arr) =&gt; &#123; arr.sort((a, b) =&gt; b - a) for (let i = 0; i &lt; arr.length - 3; i++) &#123; if (arr[i] &lt; arr[i + 1] + arr[i + 2]) &#123; return arr[i] + arr[i + 1] + arr[i + 2] &#125; &#125;&#125;console.log(fn(arr)) 42.找子结点到根结点全路径 用于 elementui 级联选择器 123456789101112131415getNodeRoute(tree, targetId) &#123; for (let index = 0; index &lt; tree.length; index++) &#123; if (tree[index].children) &#123; let endRecursiveLoop = this.getNodeRoute(tree[index].children, targetId) if (endRecursiveLoop) &#123; this.nodePathArray.unshift(tree[index].id) return true &#125; &#125; if (tree[index].id === targetId) &#123; this.nodePathArray.unshift(tree[index].id) return true &#125; &#125;&#125;","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}],"keywords":[]},{"title":"nuxt","slug":"nuxt","date":"2020-06-30T16:00:00.000Z","updated":"2021-08-11T14:08:39.716Z","comments":true,"path":"2020/07/01/nuxt/","link":"","permalink":"http://yoursite.com/2020/07/01/nuxt/","excerpt":"nuxt 服务端渲染","text":"nuxt 服务端渲染 1.一套代码，两套执行环境 所有的 js 文件都是同时存在于客户端和服务器端 只能在客户端使用 window，document，sessionStroage，使用时必须判断当前环境 beforeCreate，Created 生命周期会同时在客户端和服务器端执行，vue 中的 data 数据也可以在服务器端被打印出来 2.基础知识 nuxt 内置了 router 和 vuex，所以与此相关的代码会发生变化 在 context 中是无法使用 this 指针的，绑定在 vue 原型上的变量和方法无法使用 修改代码后记得使用 npm run dev 重启项目，热更新会有一些问题需要重启 3.引入阿里图标 iconfont.js 在 nuxt.config.js 中全局引入，必须设置 ssr:false，否则将抛出 window is not defined 修改此文件内容时需要 npm run dev 重新启动项目 也可以在 layout 目录下的 default.vue 中进行引入 12345678910// nuxt.config.jsplugins: [ \"@/plugins/element-ui\", &#123; src: \"@/assets/icon/iconfont.js\", ssr: false &#125;,];// default.vue，使用if判断当前是客户端环境时引入if (process.client) &#123; require(\"../assets/icon/iconfont\");&#125; 4.发起 axios 请求 必须使用 asyncData 才能同时在客户端和服务器端获取并渲染数据，刷新页面时不会重新发起请求，数据不会闪烁 在 created 和 mounted 生命周期函数内发起的请求只能在客户端进行渲染 1234567async asyncData() &#123; let &#123; data &#125; = await axios.get( \"https://xxx.cn/api/City/GetCityList\" ) console.log(data) return &#123; title: data &#125;&#125; 5.layout 设置找不到路径页面 layouts 文件夹下新建 null.vue 和 error.vue 文件 12345678910// null.vue&lt;div&gt; &lt;nuxt /&gt;&lt;/div&gt;// error.vue&lt;div&gt;找不到路径页面&lt;/div&gt;export default &#123; layout: \"null\"&#125; 6.vuex 使用 不需要 index.js 文件来引入 vuex 和导出 store 可以使用在子模块 state.js，mutations.js，getters.js，actions.js 中使用 export default 直接导出 state 中返回的必须是一个对象 1234567891011// state.jsexport default () =&gt; (&#123; count: 0,&#125;);// mutations.jsexport default &#123; increment(state) &#123; state.count++; &#125;,&#125;; 7.登录状态的保存 可以安装 js-cookie 依赖，因为在服务端和客户端都可以操作 cookie 直接在 js 文件中使用 sessionStorage，会报错 sessionStorage is not defined 必须判断当前是客户端环境 123if (process.client) &#123; sessionStorage.setItem(\"\", \"\");&#125; 8.在 axios 封装的 js 文件中，当状态码为 401 时，使路由跳转到登录页 因为没有 router，所以无法使用 router.push() 可以使用 window.location.href 来进行路由的跳转 必须要判断当前是客户端环境，否则会报错 window is not defined 123if (process.client) &#123; window.location.href = \"http://localhost:3000/about\";&#125; 9.npm run generate 之后使用本地 iis 打开 dist 单独点击 HTML 文件只能打开当前页面，当路由跳转时，页面会报错：找不到您的文件 在 windows10 下搜索 iis，若搜索不到则需要手动安装 控制面板-程序-启用或关闭 Windows 服务-勾选 Internet Information Services 下的 Web 管理工具和一些其他选项 打开 iis，添加网站，填写网站名称，dist 文件夹物理路径，端口即可启动浏览 10.npm run generate 之后使用 live-server 打开 dist 全局安装：npm i -g live-server dist 文件夹下：live-server 11.设置 title 前的小图标 新建 static 文件夹，放入 favicon.ico 图标；必须为 static 文件夹，且图标必须为 ico 12.nuxt 项目 url 带中文参数报错 必须使用 encodeURIComponent 先进行转义 13.将查看网页源代码中的 css 提取到 css 文件1234// nuxt.config.js 的build中添加extractCSS: &#123; allChunks: true;&#125; 14.nuxt 项目报错 网站首页显示 500，其它页面正常，没有进入到 500 错误页 本地启动报错：certificate has expired 解决：存在 api 所在的服务器 SSL 证书过期，更换即可 15.配置环境变量 安装依赖：cnpm i cross-env –save 1234567891011121314151617181920// nuxt.config.jsenv: &#123; BASE_URL1: process.env.BASE_URL1, BASE_URL2: process.env.BASE_URL2, NODE_ENV: process.env.NODE_ENV&#125;// package.json\"scripts\": &#123; \"dev\": \"cross-env BASE_URL1=https://xxx.cn/ BASE_URL2=xxx NODE_ENV=devlopment nuxt\", \"qa\": \"cross-env BASE_URL1=https://xxx.cn/ BASE_URL2=xxx NODE_ENV=qa nuxt build\", \"build\": \"cross-env BASE_URL1=https://xxx.cn/ BASE_URL2=xxx NODE_ENV=production nuxt build\"&#125;// default.vuecreated() &#123; console.log('当前环境：' + process.env.NODE_ENV) console.log('当前环境api1：' + process.env.BASE_URL1) console.log('当前环境api2：' + process.env.BASE_URL2)&#125; 16.隐藏 window.NUXT 无法实现，改 npm 包会有副作用 issues 地址 17.实现服务端渲染进行分页 将 pagesize 挂载到 url 上 18.不报错的错误 本地启动正常，控制台无报错，自动部署也无报错，页面却打不开，提示：Server error 可能是因为包含 http 请求，需要将 http 全部换成 https 19.自动部署时间长达几十分钟， cnpm i 太慢 下载 node-sass 包时，从 GitHub 上面拉取代码，速度会很慢 本地快是因为有缓存，可以在 linus 服务器上设置缓存","categories":[],"tags":[{"name":"nuxt","slug":"nuxt","permalink":"http://yoursite.com/tags/nuxt/"}],"keywords":[]},{"title":"uniapp","slug":"uniapp","date":"2020-05-31T16:00:00.000Z","updated":"2021-08-11T14:25:15.491Z","comments":true,"path":"2020/06/01/uniapp/","link":"","permalink":"http://yoursite.com/2020/06/01/uniapp/","excerpt":"uniapp 多端小程序开发","text":"uniapp 多端小程序开发 1. 双大括号中不能包裹对象 在 data 中定义空数组[]，在 template 中会被默认转为空字符串’’，可用==验证 2.picker 组件无法使用 v-model 使用 e.target.value 来获取值 3.数据在开发者工具可以获取，在真机上获取不到 接口 url 使用``模板字符串不能换行，微信开发者工具请求正常，真机调试会报 404 4.发布后，手机扫码显示页面不存在 上传之后可以拥有一个体验版本，需要管理员分配权限 修改页面路径：pages/index/index 必须和 pages.json 中的路径匹配 5.v-for 传参报错 undefined123456789&lt;view v-for=\"(index) in 10\" :key=\"index\" @click=\"fun(index)\"&gt; &#123;&#123;index&#125;&#125;&lt;/view&gt;// 必须加上item&lt;view v-for=\"(item,index) in 10\" :key=\"index\" @click=\"fun(index)\"&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;item&#125;&#125;&lt;/view&gt; 6.变量初始赋值为空字符串’’时，无法响应式赋值为 0123456789// 此时test控制台输出0，但是页面没有变化test: ''&lt;view&gt; &lt;view @click=\"test=0\"&gt;点击我&lt;/view&gt; &#123;&#123;test&#125;&#125;&lt;/view&gt;// 必须初始将其赋值为数字test: -1 7.使用百度小程序打开 uniapp 项目 必须点发行创建 unpackage 目录，并且在百度小程序开发者工具中选中 dev 下的 mp-baidu 文件夹 8.hbuild 设置启动页 pages 数组中第一项表示应用启动页 必须将启动页放到第一个 也可通过添加编译模式直接打开其它路径的页面 9.登录微信后台 微信开放平台：用来管理网站，公众号，小程序等 微信公众平台：微信小程序的管理后台 10.实现微信静默登录 先获取临时 code，并将其作为参数传递 根据 appid+secret+js_code 获取到 openid，session_key，unionid 必须在微信开放平台绑定小程序才能获取到 unionid 通过将 unionid 传给后台获取用户的所有信息以及 token 123456789101112131415161718192021222324252627282930313233343536373839// 微信登录oauth(value) &#123; uni.login(&#123; provider: 'weixin', success: res =&gt; &#123; this.login(res.code); &#125;, fail: err =&gt; &#123; console.error('授权登录失败'); &#125; &#125;);&#125;,// 获取用户认证login(js_code) &#123; uni.request(&#123; url: 'https://api.weixin.qq.com/sns/jscode2session?appid=XXX&amp;secret=XXX&amp;js_code=' + js_code + '&amp;grant_type=authorization_code', success: res =&gt; &#123; console.log(res); &#125; &#125;);&#125;,// 获取到的dataopenid: \"XXX\"session_key: \"XXX\"unionid: \"XXX\"// 通过微信可获取到部分用户信息，没啥用&lt;button open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"onGotUserInfo\"&gt;获取用户信息&lt;/button&gt;uni.getUserInfo(&#123; provider: 'weixin', success: infoRes =&gt; &#123; console.log(infoRes); &#125;, fail: err =&gt; &#123; console.error('授权登录失败：' + JSON.stringify(err)); &#125;&#125;); 11.请求响应的状态码 400，401 等状态码在 success 函数中获取，5XX 状态码在 fail 函数中获取 接口规范：默认只返回 200，500 状态码 12.下拉刷新 onPullDownRefresh data 中的数据不会被重置 轮播图的图片不会回到第一页 在所有请求执行完毕后关闭动画 1234567891011121314151617181920212223onPullDownRefresh() &#123; Promise.all([this.getBanner(), this.getCount(), this.getPerson(), this.getNews()]).then(res =&gt; &#123; uni.stopPullDownRefresh(); &#125;);&#125;,methods: &#123; // 获取轮播图图片 getBanner() &#123; return new Promise((resolve, reject) =&gt; &#123; uni.request(&#123; url: this.$api + 'api/adverts/GetAdvertByDisplayPage', data: &#123; displayPage: 'APP主页顶部' &#125;, success: res =&gt; &#123; resolve(res); console.log(\"getBanner\") this.bannerImg = res.data.ResponseObject; &#125; &#125;); &#125;); &#125;,&#125; 13.建议使用 h5 调试 修改代码刷新页面，效果呈现更快 14.路由回跳携带参数 此方法 h5 不可用 123456789101112131415161718back(cityName) &#123; // #ifdef MP-WEIXIN||MP-BAIDU let pages = getCurrentPages(); let prevPage = pages[pages.length - 2]; prevPage.setData(&#123; cityName &#125;); // #endif uni.navigateBack();&#125;onShow() &#123; // 获取城市名 // #ifdef MP-WEIXIN||MP-BAIDU let pages = getCurrentPages(); let currPage = pages[pages.length - 1]; this.cityName = currPage.data.cityName; // #endif console.log(this.cityName)&#125; 15.去除 navigator 跳转点击时的背景色1&lt;navigator hover-class=\"none\" url=\"../index/calculator\"&gt;&lt;/navigator&gt; 16.对 request 请求进行封装 Storage 在 h5 下默认存 localStorage 存在 token 就将其添加到 header 中 token 过期则跳回登录页 对 fail 函数做统一的错误弹框提示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// utils/requestconst request = (url, data, method = 'GET') =&gt; &#123; const baseURL = 'https://xxx.cn/' let access_token = '' // h5下默认存localStorage uni.getStorage(&#123; key: 'storage_key', success: function (res) &#123; // 存在便赋值 access_token = res.data.access_token &#125; &#125;) return new Promise((resolve, reject) =&gt; &#123; uni.request(&#123; url: baseURL + url, data, method, header: &#123; authorization: `bearer $&#123;access_token&#125;` &#125;, success: (res) =&gt; &#123; if (res.statusCode === 401) &#123; // 登录过期则跳回登录页 uni.navigateTo(&#123; url: '/pages/login/login' &#125;) &#125; else &#123; resolve(res.data) &#125; &#125;, fail(err) &#123; reject(err) // 提示服务器错误 uni.showToast(&#123; icon: 'none', title: '服务器错误!' &#125;) &#125; &#125;) &#125;)&#125;export default request// main.js 挂载到vue上import request from './utils/request.js'Vue.prototype.$request = request// .vue文件中使用，对比可知简洁很多this.$request('api/Articles/GetArticleByPage', &#123; categoryName: '社保资讯'&#125;).then((res) =&gt; &#123; this.newsArr = res.ResponseObject.Items.slice(0, 4)&#125;) 17.web-view 跳转 必须是验证为企业，才可以配置业务域名 业务域名为 web-view 跳转的 url 的域名 校验文件必须先放到项目根目录下可以访问，才能配置业务域名成功 若是跳转公众号网页，本地还需要配置该公众号开发者权限 18.app.json 全局配置文件 pages：页面的路径 window：窗口表现 tabBar：底部导航 networkTimeout：网络超时时间 bindtap data-name open-type data-hi 19.在微信小程序中使用 less vscode 下载插件：easy less 首选项-&gt;设置-&gt;搜索 easy-&gt;添加”outExt”: “.wxss” 在文件中新建.less 文件，此时会自动转成.wxss 文件 20.scale 不兼容1234scale:&#123;&#123;roomScale&#125;// 必须这样写transform:scale(&#123;&#123;roomScale&#125;&#125;,&#123;&#123;roomScale&#125;&#125;) 21.在自定义组件中使用 vant 样式修改必须设置到 app.less，在当前组件设置无效 或者在自定义组件中加入如下代码 123options: &#123; styleIsolation: 'shared'&#125;, 22.特殊机型顶部和底部距离的兼容12345678910111213141516171819202122232425262728293031323334353637383940414243// App.vue&lt;script&gt;export default &#123; globalData: &#123; headerHeight: 0, statusBarHeight: 0, isPhoneX: false, baseUrl: process.env.VUE_APP_API_URL || 'https://xxx.cc' &#125;, onLaunch() &#123; const &#123; model, system, statusBarHeight &#125; = wx.getSystemInfoSync(); let headHeight; if (/iphone\\s&#123;0,&#125;x/i.test(model)) &#123; this.globalData.isPhoneX = true; headHeight = 88; &#125; else if (system.indexOf('Android') !== -1) &#123; headHeight = 68; &#125; else &#123; headHeight = 64; &#125; this.globalData.headerHeight = headHeight; this.globalData.statusBarHeight = statusBarHeight; &#125;&#125;;&lt;/script&gt;// .vue文件中设置距离&lt;view class=\"title\" :style=\"&#123; paddingTop: (headerHeight + statusBarHeight) / 2 - 12 + 'px' &#125;\"&gt; &lt;view class=\"arrow\" @click=\"toRoom\"&gt; &lt;van-icon name=\"arrow-left\" /&gt; &lt;/view&gt; 云视频&lt;/view&gt;onLoad() &#123; // 设置顶部padding高度 const appData = getApp().globalData; this.headerHeight = appData.headerHeight; this.statusBarHeight = appData.statusBarHeight; if (appData.isPhoneX) &#123; this.isPhoneX = appData.isPhoneX; &#125;&#125; 23.在小程序中使用 axios12345678910111213141516171819202122232425262728293031323334import axios from 'axios'import adapter from 'axios-miniprogram-adapter'const service = axios.create(&#123; baseURL: process.env.VUE_APP_API_URL || 'https://xxx.cc', adapter, headers: &#123; 'content-type': 'application/x-www-form-urlencoded', // 默认值 Accepts: 'application/json' &#125;&#125;)// 请求拦截器service.interceptors.request.use( function (config) &#123; return config &#125;, function (err) &#123; return Promise.reject(err) &#125;)// 响应拦截器service.interceptors.response.use( function (res) &#123; // resolve(res.data) return res.data &#125;, function (err) &#123; return Promise.reject(err) &#125;)export default service 24.获取页面路径所携带的参数123onLoad: function(options) &#123; console.log(options)&#125; 25.多张图片上传成功后再执行操作1234567891011121314151617181920212223242526272829303132333435363738394041424344// 将上传转promisepromiseUpload(item) &#123; const that = this; return new Promise((resolve, reject) =&gt; &#123; wx.uploadFile(&#123; url: getApp().globalData.baseUrl + '/api/base/file/uploadFile', filePath: item, name: 'file', formData: &#123; typeFlag: 'img', ptfTopClinicId: that.bookingInfoData.ptfTopClinicId &#125;, success(res) &#123; resolve(JSON.parse(res.data).fileId); &#125;, fail(err) &#123; m(err); &#125; &#125;); &#125;);&#125;,// 上传图片uploadImg() &#123; const that = this; wx.chooseImage(&#123; success(res) &#123; Promise.all( res.tempFilePaths.map(item =&gt; &#123; return that.promiseUpload(item); &#125;) ).then(res =&gt; &#123; that.$api .updateVideoVisit(&#123; clnVisitId: wx.getStorageSync('visitId'), imgIdArr: JSON.stringify(res) &#125;) .then(res =&gt; &#123; Toast(&#123; message: '图片上传成功', context: that &#125;); that.getBookingInfo(); &#125;); &#125;); &#125; &#125;);&#125;, 26.引入 vant weapp 内置样式1// @import 'miniprogram_npm/@vant/weapp/common/index.wxss'; 27.小程序分包 在 pages 的同级目录下创建 packageA 文件夹 修改配置需要重新启动项目，可在 dist 目录下找到对应的分包文件 1234567891011121314// pages.json分包配置\"subpackages\": [ &#123; \"root\": \"packageA\", \"pages\": [ &#123; \"path\": \"list/index\" &#125; ] &#125;],// 页面跳转&lt;navigator url=\"/packageA/list/index\" class=\"navigator\"&gt;去list页&lt;/navigator&gt;","categories":[],"tags":[{"name":"uniapp","slug":"uniapp","permalink":"http://yoursite.com/tags/uniapp/"}],"keywords":[]},{"title":"npm","slug":"npm","date":"2020-04-30T16:00:00.000Z","updated":"2021-09-13T02:27:56.220Z","comments":true,"path":"2020/05/01/npm/","link":"","permalink":"http://yoursite.com/2020/05/01/npm/","excerpt":"npm 使用","text":"npm 使用 1.npm 基本命令 初始化 package.json：npm init 安装到开发环境依赖：npm install –save(-S) 安装到生产环境依赖：npm install –save-dev(-D) 全局安装：npm install(i) -g 全局移除：npm uninstall -g 全局更新：npm update -g 查看全局包：npm list -g –depth 0 查看全局包的安装路径：npm root -g(默认地址：/usr/local/lib/node_modules) 查看帮助：npm help 查看源地址：npm config list 显示所有配置：npm config ls -l 查看包信息：npm info 完整的命令 2.设置源 安装 cnpm 淘宝源；npm install -g cnpm –registry=https://registry.npm.taobao.org 设置 npm 为淘宝源：npm config set registry https://registry.npm.taobao.org npm 切回原地址：npm config set registry https://registry.npmjs.org/ 查看当前源：npm config get registry 3.npm 镜像源管理工具 nrm 的使用 全局安装：npm i -g nrm 查看可选源：nrm ls 添加源并指定名称：nrm add ktcc http://xxx.com 切换使用源：nrm use ktcc 查看当前源：nrm current 删除源：nrm del xxx 测试源速度：nrm test xxx 12npm ---- 1473mscnpm ---- 221ms 4.npm 发布自己的组件包 npm login 返回 401：切换源为 npm config set registry https://registry.npmjs.org/ npm publish 返回 403：更换包名，可能该包名已存在 npm i xxx 返回 400：每次发布 npm 包需要修改版本号 npm init：创建 package.json npm login：依次输入用户名，密码，邮箱 npm publish：发布 npm unpublish xxx –force：删除包 npm deprecate xxx ‘弃用’：弃用包，当该包自身安装了自身的依赖时，无法删除 查看镜像：npm get registry 设置淘宝镜像：npm config set registry http://registry.npm.taobao.org/ 换成原来镜像：npm config set registry https://registry.npmjs.org/ cnpm 拉取包不是最新：进入https://npm.taobao.org/ 搜索自己的包名，点击 SYNC 注意：同名的包一旦删除，需 24 小时后才能重新发布，包安装自身依赖将无法被删除 实际开发中，npm 包应为单独的一个项目，默认发布整个项目文件 12345678910111213141516171819202122232425// package.json&#123; \"name\": \"npmDemo\", // 发布的包名，不能和已有的重复 \"version\": \"1.0.0\", // 发布的版本号，每次发布都需要修改 \"description\": \"\", // 包的描述 \"main\": \"1.js\", // 主入口文件 \"private\": false, // 设置为公有 \"files\": [] , // 新添加，可在此处指定文件 \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", // 作者 \"license\": \"ISC\", \"dependencies\": &#123; \"npmDemo\": \"^1.0.0\" &#125;&#125;// .npmignore/node_modules// 文件引入，不可省略.vue后缀，否则找不到import HeaderCom from \"yc-common/src/components/HeaderCom.vue\";import \"yc-common/1.js\"; 5.yarn 的使用 yarn 安装全局包需要额外配置系统环境变量路径 初始化：yarn init -y 安装依赖：yarn 添加依赖：yarn add xxx (–dev) 移除依赖：yarn remove xxx 升级依赖：yarn upgrade xxx 查看全局包：yarn global list 查看当前源： yarn config get registry 安装淘宝源：yarn config set registry https://registry.npm.taobao.org","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}],"keywords":[]},{"title":"git","slug":"git","date":"2020-03-31T16:00:00.000Z","updated":"2021-11-24T08:34:31.957Z","comments":true,"path":"2020/04/01/git/","link":"","permalink":"http://yoursite.com/2020/04/01/git/","excerpt":"git 版本控制","text":"git 版本控制 1.git 常用操作 创建仓库：git init 添加到暂存区：git add . 添加文字描述：git commit -m “改动描述” 添加仓库地址： git remote add origin https://github.com/xxx.git 提交代码：git push -u origin master 克隆代码：git clone 仓库地址 (–depth=1)(.cnpmjs.org) 更新代码：git pull 删除文件：git rm 文件名 查看状态：git status 查看修改：git diff 查看历史：git log(q 退出) 查看版本：git –version 恢复提交：git stash 撤销提交：git reset –soft head^ 2.分支操作 创建分支：git branch 分支名 删除本地分支：git branch -d 分支名 删除远程分支：git push origin –delete 分支名 切换分支：git checkout 分支名 查看当前分支：git branch 合并到当前分支：git merge 分支名 3.系统配置 查看当前用户配置：git config –global –list 设置用户名：git config –global user.name “xxx” 设置邮箱：git config –global user.email “xxx” 生成 ssh 密钥：ssh-keygen -t rsa -C xxx@163.com 查看密钥：cat /root/.ssh/id_rsa.pub 4.版本回退 回退上一版本：git reset –hard HEAD~1 回退三个版本前：git reset –hard HEAD~3 回退到指定的版本：git reset –hard 提交 id 强制推送：git push -f 5.svn 常用操作 克隆代码：svn co/checkout 仓库地址 更新代码：svn up/update 添加到版本库： svn add * 删除文件：svn delete 文件名 提交代码：svn commit -m “改动描述” 查看信息：svn info 6.vscode 内使用 svn 忽略提交：右击，选中 Set changelist 取消忽略：右击，选中 Set changelist 当是新添加的文件时，需要先 add 进修改文件里面 当提交多个修改文件时，可以选择需要提交的文件，若是一个则直接提交 7.其他 Sourcetree 客户端 git 下载 git 命令 cornerstone 客户端破解 SVNBucket 地址 svn 教程 8.实际项目开发 方式一：fork 原项目，将修改后的代码推送到 fork 的仓库，然后再推送合并到原项目地址 方式二：新建一个分支，将修改后的代码推送到新分支，然后再推送合并到主分支 注意：修改邮箱地址后，之前暂存的修改要撤销后重新暂存，之前暂存的修改记录了之前的邮箱地址 删除远端分支后，可使用 vscode 删除本地分支 12345678// 新分支推送到远端，也可直接点击vscode左下角图标git push --set-upstream origin dev_yuancheng// 删除远端分支git push origin --delete dev_yuancheng// 更新本地分支git remote update origin 9.git 提交规范 feat：添加新功能 fix：bug 修复 perf：代码优化 style：样式改动 docs：文档补充 refactor：代码重构 test：增加测试 chore：构建过程或辅助工具的改动 10.打 tag 标记 查看本地 tag：git tag 推送本地 tag：git push origin –tags","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"keywords":[]},{"title":"hexo","slug":"hexo","date":"2020-02-29T16:00:00.000Z","updated":"2021-08-10T16:13:34.975Z","comments":true,"path":"2020/03/01/hexo/","link":"","permalink":"http://yoursite.com/2020/03/01/hexo/","excerpt":"hexo 搭建博客","text":"hexo 搭建博客 1.官方文档 Hexo 官网 NexT 主题 Snippet 主题 2.环境配置 下载并成功安装Node.js 下载并成功安装Git 安装 Hexo 1npm install hexo-cli -g 3.创建文件完成初始化12hexo initnpm install 4.本地启动验证是否成功初始化1hexo s 5.部署到 GitHub1.注册 GitHub 账号，并创建仓库(Enjoy-yuan.github.io) 2.修改配置文件_config.yml 123deploy: type: git//github.com/Enjoy-yuan/Enjoy-yuan.github.iorepo: https: branch: master 3.生成公钥输入命令后直接回车，xxx@qq.com 替换为你设定的 GitHub 的邮箱 1ssh-keygen -T rsa -C \"xxx@qq.com\" 4.配置 SSH-Key 在 github 上配置 ssh-key 5.连接 github输入以下命令后，输入 yes 1ssh -T git@github.com 6.安装 git 包 1npm install hexo-deployer-git --save 7.设置用户信息 12git config --global user.name \"xxx\"git config --global user.email \"xxx@qq.com\" 8.部署到 GitHub，通过 enjoy-yuan.github.io 来访问博客 1hexo d 6. 博文上传1hexo g -d 7.添加标题，时间，标签，分类，简介12345678---title: hexodate: 2019-02-01tags: hexocategories: 前端---hexo搭建博客&lt;!-- more --&gt; 8.搭载简历 在 source 文件夹下新建文件夹 static 放入简历 my.pdf 在首页添加路径/static/my.pdf 即可访问 9.博客迁移重新连接 ssh，替换：source，themes，_config 文件夹，之后输入命令 12hexo cleanhexo g -d 10.代码高亮 修改配置文件_config.yml 12345highlight: enable: true line_number: true auto_detect: true tab_replace: 11.绑定域名(需要备案) 到阿里云购买域名 云解析 DNS - 解析设置 - 添加解析","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"keywords":[]},{"title":"vscode","slug":"vscode","date":"2020-01-31T16:00:00.000Z","updated":"2021-09-27T07:30:58.967Z","comments":true,"path":"2020/02/01/vscode/","link":"","permalink":"http://yoursite.com/2020/02/01/vscode/","excerpt":"vscode 使用","text":"vscode 使用 1.必备插件 one dark pro：颜色主题 Snazzy Operator：颜色主题 Material Icon Theme：图标主题 Code Runer：运行 js 代码 Browser Preview：在 vscode 内打开浏览器 View in Browser：在浏览器打开 HTML 文件 Markdown PDF：制作 PDF 简历 Auto Close Tag：标签自闭合 Auto Rename Tag：标签自动重命名 Beautify：美化代码 Prettier：格式化代码 Chinese Language：中文语言包 vscode-icons：文件图标 HTML Snippets：代码自动填充 Path Intellisense：文件路径自动补全 GitLens：git 远程仓库管理 SVN：svn 代码版本管理 Git History：查看 git 提交历史 minapp：原生微信小程序代码格式化 Javascript Booster：优化代码 Auto Import：自动引入文件 Live Server：搭建本地服务器环境 2.常用快捷键 option =&gt; alt command =&gt; control command+p：文件搜索 command+w: 关闭当前标签 command+k command+w: 关闭所有标签 control+`: 显示隐藏终端 command+b: 显示隐藏侧边栏 command+]/[: 缩进行 command+k v: 拆分双屏预览 markdown shift+option+f：格式化文档 command+option+s：全部保存 command+shift+p：显示所有命令 command+z：撤销 command+shift+z：反撤销 command+shift+v：打开新标签预览 markdown command+shift+c：打开当前文件根目录的控制台 command+shift+n：打开新的窗口 command+shift+w: 关闭当前窗口 3.设置 vue 模板 command+shift+p =&gt; snippets =&gt; vue 123456789101112131415161718192021222324&#123; \"Print to console\": &#123; \"prefix\": \"vue\", \"body\": [ \"&lt;template&gt;\", \" &lt;div&gt;\\n\", \" &lt;/div&gt;\", \"&lt;/template&gt;\\n\", \"&lt;script&gt;\", \"export default &#123;\", \" data () &#123;\", \" return &#123;\\n\", \" &#125;\", \" &#125;\", \"&#125;\", \"&lt;/script&gt;\\n\", \"&lt;style lang='scss' scoped&gt;\\n\", \" \", \"&lt;/style&gt;\", \"$2\" ], \"description\": \"Log output to console\" &#125;&#125; 4.settings.json 配置123456789101112131415161718&#123; // 设置颜色主题 \"workbench.colorTheme\": \"Snazzy Operator\", // 设置图标主题 \"workbench.iconTheme\": \"material-icon-theme\", // 设置字体大小 \"editor.fontSize\": 14, // 设置prettier扩展格式化4个空格 \"prettier.tabWidth\": 4, // 设置prettier扩展格式化单引号 \"prettier.singleQuote\": true, // 设置prettier扩展末尾不带分号 \"prettier.semi\": false, // 设置prettier扩展末尾不带逗号 \"prettier.trailingComma\": \"none\", // 设置prettier扩展代码宽度130 \"prettier.printWidth\": 130,&#125; 5.其它 保留当前标签页：双击当前文件 代码无法格式化：点击右下角 prettier mac 上查看隐藏的文件：command+shift+. mac 上谷歌浏览器打开控制台：command+option+i 打开 smb：打开 Finder，command+k 设置打开终端快捷键：进入自动操作 =&gt; 双击 AppleScript =&gt; 输入如下代码保存为打开终端；访达 =&gt; 服务 =&gt; 服务偏好设置 =&gt; 找到打开终端设置快捷键 command + q 1234567on run &#123;input, parameters&#125; (* Your script goes here *) tell application \"Terminal\" reopen activate end tellend run","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}],"keywords":[]},{"title":"outline","slug":"outline","date":"2019-12-31T16:00:00.000Z","updated":"2021-11-22T10:21:49.512Z","comments":true,"path":"2020/01/01/outline/","link":"","permalink":"http://yoursite.com/2020/01/01/outline/","excerpt":"前端学习大纲","text":"前端学习大纲 1.前端工程师技能清单 基本技能：Html5，Css3，JavaScript CSS 进阶：Sass/Less/Stylus js 进阶：TypeScript，ES6，ES7 热门框架：Vue/React/Angular 服务端渲染：Nuxt/Next 后端语言：Node/Java/C#/Python/C++ Node 开发：Express/Koa/Egg/Nest 数据库：MySQL/MongoDB 2.前端必备工具 科学上网：佛跳墙 笔记工具：简书 取色工具：TakeColor 录屏工具：ScreenToGif 看图软件：光影看图 标注工具：PxCook 切图工具：Photoshop CC api 调试：Postman 开发工具：VS Code/HBuilder/WebStorm 调试工具：Chrome DevTools 图片转文字：https://txt.wxzzz.com/ git 可视化操作：Sourcetree 数据库可视化：Navicat 思维导图工具：XMind，MindNode 矢量图标库：iconfont，easyicon，iconfinder，fontawesome React 组件库：ant-design Vue 组件库：Element，vant，vant weapp 微信小程序：uni-app，mpvue，chameleon，Taro 数据可视化工具：Echarts，Highcharts，D3 ssh 连接 linux：FinalShell/Xshell6 文件上传服务器：filezilla/xftp 反向代理：nginx markdown 简历制作：vs code 插件，Markdown PDF 接口数据 mock：fastmock 免费 CDN（不稳定）：bootcdn.cn/jsdelivr markdown 软件：Typora 接口文档：ShowDoc 3.Chrome 插件 永久免费翻墙工具：SetupVPN(失效) 谷歌访问助手：支持部分翻墙 有道智能翻译：划词翻译和全文翻译 书签侧边栏：书签管理 Octotree：在 Github 上直接浏览代码 React Developer Tools：react 开发 Vue.js devtools：vue 开发 JSON-Viewer：预览 json Momentum：主题 PageSpeed Insights：对指定 url 进行性能测试(需翻墙) LightHouse：性能测试 4.基础学习 MDN free-programming-books JavaScript 标准参考 ECMAScript 6 入门 ES6 在线转换 chrome 开发者工具(需翻墙) ES6 转 ES5 5.大牛博客 阮一峰的个人博客 张鑫旭 朴灵 廖雪峰 汤姆大叔 一像素 kraaas 6. 后台管理系统 vue-element-admin lin-cms-vue 7.前端面试题 前端面试题 1 前端面试题 2 前端面试题 3 前端面试题 4 前端面试题 5 8.学习网站 掘金 SegmentFault CSDN 牛客网 哔哩哔哩 腾讯课堂 网易云课堂 慕课网 极客学院 码农周刊 前端周刊 9.移动端插件 mobileSelect.js：替代原生下拉框 swiper：移动端原生轮播图 cropper：移动端原生图片裁剪 10.vue 小插件 图片懒加载：vue-lazyload 警告弹框：sweetalert 表单验证：vee-validate 瀑布流无限滚动：vue-infinite-scroll 进度条：nprogress 模拟 REST API：json-server 处理日期时间：dayjs 移除没用的 css：purgecss 轮播图：vue-awesome-swiper 富文本：tinymce 持久化：vuex-persistedstate 11.设计素材网站 调色板 插画 1 插画 2 站酷 字体 gratisography splitshire photopin pixabay 12.算法刷题 leetcode hot200 剑指 offer leetcode hot100 13.优秀 github 低代码 组件库","categories":[],"tags":[{"name":"outline","slug":"outline","permalink":"http://yoursite.com/tags/outline/"}],"keywords":[]}]}